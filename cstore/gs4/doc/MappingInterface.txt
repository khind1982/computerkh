Mapping Interface.

This document describes the interface exposed by AbstractMapping and
subclasses. It is in a state of flux at the moment, but is stabilising
and becoming fairly consistent and perspicuous.

AbstractMapping should be used as the base class for all Mapping
objects, as it exposes several convenience methods and callback hooks
that can be used to achieve very sophisticated processing of the input
data stream. It is a new-style class (that is, it inherits directly
from the builtin 'object' type), so can take advantage of the new
class syntax and semantics. Subclasses therefore automatically inherit
this behaviour at instantiation.

AbstractMapping's __init__() sets various properties on each created
instance:

        _dtable : a dispatch table of the functions to call for each
        field in the objects delivered from the data stream

        _rawrecord : the legacy object being mapped. This is what is
        returned on each iteration of the DataStream's streamdata()
        method.

        _fields : a list of field names from the legacy data object. It
        is used to populate self.record, described next.

        _record : an instance of LegacyRecord (itself an instance of
        the abstract Struct class, which can be used like a struct()
        in C, but which accepts dynamic assignment to new attributes 
        at runtime), which is populated with the field names and
        values from the input data objects. It can be addressed either
        as a dictionary object, or using standard dotted attribute
        address notation (e.g. self.record._fields['title'] is the
        same as, but uglier to read than, self.record.title). The
        properties defined on this LegacyRecord instance will depend
        on the fields defined in each input record.

        gs4 :    an instance of GS4Record(Struct), which, like
        LegacyRecord, can be assigned to dynamically and addressed in
        a similar fashion. The interface is left deliberately vague,
        in order to be flexible enough to allow mappings from many
        different legacy products. There are a few expectations on the
        format of the data attached to an instance of GS4Record; these
        will be covered later.

        _computedValues : a list of callback methods that are invoked
        by AbstractMapping.computedValues(), described below.        

It also defines several methods that are inherited by subclasses:

        __getattr__()   : Standard Python approach to overloading
        container access. It is this method that allows the two types
        of attribute access described above. (Struct, the superclass
        of both LegacyRecord and GS4Record, has its own implementation
        of __getattr__(), which is what allows attribute access calls
        to be chained: self.record.title, etc)

        notImplemented()    : This is a convenience method, useful
        during the implementation of a new product's mapping. If an
        attribute's entry in self._dtable is None, notImplemented() is
        triggered, causing the name of the field to be printed to
        STDERR, and execution to stop. It acts as a reminder of what
        needs to be done.

        noop()   : fields that are not required in the output should
        have noop() assigned as their callback in _dtable. It does
        nothing, but doesn't trigger notImplemented. Therefore, the
        programmer must explicitly set the callback to noop(). It is
        also useful in cases where a simple one-to-one mapping of a
        legacy attribute to a GS4 attribute is not possible - for
        example, where several fields in the legacy object need to be
        converted to a single type of element in the GS4 record. In
        most cases, the GS4 element will need attributes on the XML
        element, in order to retain the differentiation that was
        achieved by using different field names in the older
        version. GS4 Terms and Contributors are good examples - in the
        legacy data, each term type is represented by a separate field
        name, whereas in GS4, the distinction is made by setting the
        attribute "TermType" on the Term element. Your implementation
        should assign AbstractMapping.noop as the value in the _dtable
        for all affected fields, and you should then define and
        register a callback method in self._computedValues which will
        be invoked by do_mapping() (see details below).

        fixme()   : similar to notImplemented, but it prints the name
        of the field to STDERR and allows execution to continue. It is
        triggered if the value in the _dtable for an attribute is
        'FIXME'. Useful to avoid notImplemented from bailing out, but
        when you haven't yet finalised the implementation of the
        method in question.

        do_mapping() : the core method of the Mapping object. It is
        responsible for invoking the methods in the _dtable. If you
        need to customise its behaviour, simply define do_mapping() in
        your subclass, and call AbstractMapping.do_mapping() at the
        appropriate place. It also calls
        AbstractMapping.computedValues, which in turn calls any
        registered callbacks in the self._computedValues list.

        computedValues() :   invoked as the final stage of the default
        implementation of do_mapping(). Methods registered as
        callbacks in the self._computedValues list are called, in
        order. These are useful for the cases mentioned above - such
        as the multiple term types that are found in the legacy data,
        but which must be mapped to Term elements in the GS4 format,
        with attributes on the elements.

As well as the attributes and methods mentioned above, you may also
define two further callback methods in your subclasses (the
implementations in AbstractMapping simply raise an exception when
invoked, which is caught in the try: except: in transform):

        before_hooks() and after_hooks() : a pair of callbacks that
        are invoked respectively, before and after the main mapping
        method is called. They can be used for any purpose relevant to
        the legacy product being mapped, or to provide visual feedback
        of the application's progress through the data stream, to halt
        execution after a certain number of records have been
        processed, etc. There are no limitations on what can be done
        here, except the limitations imposed by the language
        itself. The hooks are invoked inside a try: except: in the
        master script (./bin/transform), which in turn is inside a
        for: loop, so provided you raise exceptions and handle them in
        transform, you can skip processing of a particular record if
        desired. The implementation is functional, but not yet
        complete, so if you make use of these callbacks, don't be too
        surprised if they stop working! I intend to generalise the
        implementation, so that all behaviour associated with the
        callbacks can be defined in the Mapping class, and not rely on
        having to declare new Exception types to handle all the cases
        that will doubtlessly crop up as the number of products in
        CStore increases.



General Flow

Once you have encapsulated your legacy data in a datastream object,
transform iterates over the stream, and in turn, instantiates a
mapping object for the data stream object, then calls before_hooks(),
do_mapping() and after_hooks() on the mapping object. Note that if
before_hooks and after_hooks are not defined, execution continues
because the transform script catches the exception objects raised by
AbstractMapping.before_hooks() etc, and just calls "pass". (This
works because the exception is caught in a loop context).

Once the mapping is complete, the Transformation object now contains
the GS4Record instance, which is passed to the filter classes and
output as appropriate.

In order for the templates to be correctly filled in, it is important
that you populate the GS4Record instance correctly. For simple text
data with no further associated attributes, simply insert a unicode
string object. Other cases are more complex, and in general should be
handled by writing a helper method and registering it as a
computedValues callback. For example, the current implementation
includes _abstract() and _contributors() methods, which make sure the
values and attributes are correctly assigned inside the GS4Record.


GS4Record interface

Although the implementation of GS4Record is about as vague as it is
possible to be in a Python class, in order for the Cheetah templates
to work correctly, you must make sure that any instance of GS4Record
follows the interface outlined below. Note that the list is
incomplete, because we don't yet know about all the different
attributes on all the different products we are going to need to map.

title: text: Article title
journalID: text: Journal ID
pubTitle: text: Publication title
ethnicity: text: A string representing the Ethnicity property.
searchObjectType: text: 

docFeatures: list: items to be mapped as DocFeatures. These can be
taken straight from the source - it is not an enumerated type.

