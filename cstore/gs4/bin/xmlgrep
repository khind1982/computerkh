#!/usr/local/bin/python2.6
# -*- mode: python -*-

import sys, os, site
sys.path.append(os.path.join(os.path.dirname(__file__) + '/../lib/python'))
sys.path.append('../lib')
site.addsitedir('/packages/dsol/lib/python2.6/site-packages')

# A utility to search an XML file for certain values, which are specified as
# XPAth=value

# We need to be able to handle files that contain many records wrapped with
# a top-level container element (such as the IIMPA source, where each <document>
# is held within a <documents> element), or files that contain many self-contained
# documents, such as the new platform handover files generated by the transformation
# app.

import re
from lxml import etree as ET
from lxml.etree import XMLSyntaxError
from StringIO import StringIO

from optparse import OptionParser

optparser = OptionParser()
# optparser.add_option(
#     '-c', dest='count', default=False, action='store_true'
#     )
optparser.add_option(
    '-v', dest='inverse', default=False, action='store_true'
    )
(options, args) = optparser.parse_args()

try:
    search_term = dict([args[0].split('=')])
except IndexError:
    print >> sys.stderr, ("Usage: {prog} [-v] XPathPattern=Value filename1 ... filenameN".format(prog=os.path.basename(__file__)))
    exit(1)
    
for element in search_term.keys():
    if re.search(r'{.*}', search_term[element]):
        filename = re.search(r'{(.*)}', search_term[element]).group(1)
        with open(filename, 'r') as infile:
            search_term[element] = [line.strip() for line in infile.readlines()]
    
if len(args[1:]) == 0:
    input_files = [sys.stdin]
else:
    input_files = args[1:]

parser = ET.XMLParser(strip_cdata=False)

def print_article(article):
    print ET.tostring(article, encoding='UTF-8', xml_declaration=True)

for f in input_files:
    try:
        inf = open(f, 'r')
    except TypeError:
        inf = f
    # The Cheetah templates use " around attribute values, 
    # whereas lxml uses '. Get the correct value for preamble
    # by qureying each file. The correct solution would be to
    # change the template to use ' as well, but we'd have to do
    # a full steady state run of IIMP/IIPA/PRISMA/BP to update
    # them properly. The path of least resistance is the road
    # to hell.
    preamble = inf.readline()
    for record in inf.read().split(preamble):
        if record == '':
            continue
        try:
            article = ET.parse(StringIO(''.join([preamble, record])), parser)
        except Exception as e:
            print record
            raise
            
        for element in search_term.keys():
            if options.inverse:
                if article.xpath(element)[0].text not in search_term[element]:
                    print_article(article)
            else:
                if article.xpath(element)[0].text in search_term[element]:
                    print_article(article)
