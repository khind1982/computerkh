#!/usr/local/bin/bash

# Control script to handle invoking the transformation app.
# It takes care of constructing the required commandline
# and calls the transformation app glue script.

# Read in the config file.

if [ -f "`dirname $0`/../etc/transformrc" ]
then
    . "`dirname $0`/../etc/transformrc"
else
    echo "No config file. Stopping."
    exit 1
fi

if [ -f "`dirname $0`/../etc/transformrc.subr" ]
then
    . "`dirname $0`/../etc/transformrc.subr"
fi

# Check the first argument. This should be the product name.

usage() {
    printf "Usage: %s productname [options]\n" $0 >&2
    echo "Options:" >&2
    echo "-F - skipt source file checksum tests" >&2
    echo "-N - don't touch the steady state database. Useful for testing" >&2
    echo "-U - force updating of the steady state checksums" >&2
    echo "-V - disable XML validation for this session" >&2
    echo "-b - rebuild the InnoData full text cache. IIMP/IIPA only" >&2
    echo "-i <directory> - read input data from named directory" >&2
    echo "-l <filename> - read transformation candidates from named file" >&2
    echo "-o <directory> - write output data to files in named directory" >&2
    echo "     Default: ${SSOUT}/\$productname" >&2
    echo "-r - resume a previous session" >&2
    echo "-v <directory> - write XML validation logging to <directory>." >&2
    echo "     Default: $HOME/validationlogs" >&2
    exit 1
}

check_product_name() {
    productname=$1
    if [ "x$productname" = "x" ]
    then
        usage
    elif [ $productname = "iimp" -o $productname = "iipa" ]
    then
        inputdata="$SSROOT/src/$productname"
    elif [ $productname = "prisma" ]
    then
        inputdata="MySQL"
    elif [ $productname = "iimpft" -o $productname = "iipaft" ]
    then
        fulltext="true"
        productname=${productname%ft}
        inputdata="$SSROOT/src/${productname}"
    else
        echo "Unknown product: $productname" >&2
        exit 1
    fi
}

check_product_name $1
shift

while getopts FNUVbi:l:o:rv: name
do
    case $name in
        F)  # STREAM
            # Disable source file checksum tests
            filechecks="no"
            ;;
        N)
            # MAPPING
            # Don't touch the steady state database
            noss="true"
            ;;
        U)
            # MAPPING
            # Force updating steady state tokens for all records
            forcess="true"
            ;;
        V)
            # VALIDATION
            # Turn off XML validation
            validate="false"
            ;;
        b)
            # MAPPING
            # Force rebuilding the InnoData derived full text
            # Only effective for IIMP/IIPA full text.
            rebuildcache="true"
            ;;
        i)
            # INPUT FILES
            # Use named directory as input
            inputdir=$OPTARG
            ;;
        l)
            # IDS FROM LIST
            # Read the list of records to transform from named file
            idsfromfile=$OPTARG
            ;;
        o)
            # OUTPUT DEST
            # wirte files to named directory, instead of /dc/dsol/steadystate/out/${product}
            outputdest=$OPTARG
            ;;
        r)
            # RESUME
            # Resume a halted or failed session
            resumedsession="true"
            ;;
        v)
            # VALIDATION
            # Send XML validation logging to named directory
            validation_logs=$OPTARG
            ;;
        ?)
        usage
        ;;
    esac
done

# If both noss and forcess are set, exit messily.
checkmutex noss forcess

# Construct argumenst to -m, if any.
mappingoptions() {
    if (checkyesno noss)
    then
        MAPPINGOPTS[${#MAPPINGOPTS[*]}]="noss"
    elif (checkyesno forcess)
    then
        MAPPINGOPTS[${#MAPPINGOPTS[*]}]="forcess"
    fi

    if (checkyesno rebuildcache)
    then
        MAPPINGOPTS[${#MAPPINGOPTS[*]}]="rebuildcache"
    fi

    if (checkyesno fulltext)
    then
        MAPPINGOPTS[${#MAPPINGOPTS[*]}]="fulltext"
    fi
    # join the elements of the array with commas and return
    echo ${MAPPINGOPTS[@]} | sed -e 's/ /,/g'
}

xmlvalidation() {
    if (checkyesno validate)
    then
        echo $validation_logs
    else
        echo
    fi
}

outputoptions() {
    # If the user specified an output destination, set it here.
    if [ "x$outputdest" = "x" ]
    then
        if [ "x$fulltext" = "xtrue" ]
        then
            outputdest=$SSOUT/${productname}ft
        else
            outputdest=$SSOUT/${productname}
        fi
    fi
    destdir="directory=${outputdest}"

    # Set the name of the output files.
    if [ "x$fulltext" = "xtrue" ]
    then
        outfile="io=CH_SS_${productname}_fulltext_`today`_"
    else
        outfile="io=CH_SS_${productname}_`today`_"
    fi
    echo "${destdir},${outfile},records=5000"
}

inputopts() {
    if [ "x$inputdir" = "x" ]
    then
        echo $inputdata
    else
        echo $inputdir
    fi
}

streamopts() {
    if [ "x$filechecks" = "xno" ]
    then
        echo "-s fileChecks=no"
    fi
}

build_command() {
    mappingopts=`mappingoptions`
    if [ "x$mappingopts" != "x" ]
    then
        mappingopts="-m $mappingopts"
    fi
    outputopts="-o `outputoptions`"
    xmldir=`xmlvalidation`
    if [ "x$xmldir" != "x" ]
    then
        xmlopts="-x $xmldir"
    fi
    if [ "x$idsfromfile" != "x" ]
    then
        idlist="-i ${idsfromfile}"
    fi
    if (checkyesno resumedsession)
    then
        resume="-r"
    fi
    streamoptions=`streamopts`
    input=`inputopts`
}

build_command

# echo "Taking input data from ${input}" >&2
# echo "Writing output to ${outputdest}" >&2

if [ `uname -s` != 'FreeBSD' ]
then
    LD_LIBRARY_PATH=/usr/local/lib
    export LD_LIBRARY_PATH
fi

time nice -n 10 ${TRANSFORM} ${resume} ${idlist} ${streamoptions} ${mappingopts} ${outputopts} ${xmlopts} ${productname} ${input}
