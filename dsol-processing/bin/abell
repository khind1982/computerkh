#!/usr/local/bin/python2.6
# -*- mode: python -*-


import sys, os, re
sys.path.append(os.path.join(os.path.dirname(__file__) + '/../lib/python'))

# A wrapper around the ABELL processes.
# This should make things a little easier...

from collections import defaultdict

# Check what we get given on the command line.
# If argv contains only the current file, break
# with a friendly usage message. Otherwise, pass
# off control to the requested function.

valid_subcommands = ['liftJnl', 'add_issn', 'addtagbylup',
                     'pqname', 'sanitise', 'mockToC',
                     'feedPreProc', 'processAbell', 'dateaddIdref',
                     'abellTidy', 'revLink', 'abSubVal', 'festCont']


if len(sys.argv) == 1:
    print "abell: a convenience wrapper for the abell processes."
    print "Usage: abell <subcommand> <args>"
    print "Available commands:"
    for sbcommand in valid_subcommands:
        print "\t" + sbcommand
    exit()
elif len(sys.argv) == 2:
    sys.stderr.write("Subcommand " + sys.argv[1] + " requires arguments!\n")
    exit(1)
elif len(sys.argv) >= 3:
    subcommand = sys.argv[1]
    args = sys.argv[2]
    for thing in sys.argv[3:]:
        args = args + ', ' + thing
    if subcommand not in valid_subcommands:
        sys.stderr.write(subcommand + " is not a valid subcommand name\n")
        exit(2)

#print args


#print dtable

#exit()

# If we get this far, we'd better import the lib!
from abell import processAbell

def sanitise(filename, date):
    if filename.endswith("new"):
        filename = filename + ".idref"
    sys.stderr.write("Running pqname()...")
    processAbell.pqname([filename])
    # Here we end up with a .idref.pqn file. Obviously.
    # Let's rename it to all_pq.new.idref, where we started
    import shutil
    shutil.move('all_pq.new.idref.pqn', filename)
    sort_log()
    searchAndReplace(filename, date)
    checkNumbers(filename)
    shutil.move(filename, 'all_pq.new')


def sort_log():
    sys.stderr.write("Sorting the output log...\n")
    log = [line.rstrip() for line in open("new_pqname.log", 'r') if line.rstrip() != '']
    log = dict.fromkeys(log).keys()
    log.sort()
    logfile = open("new_pqname.log", 'w')
    for line in log:
        logfile.write(line + "\n")
    logfile.close()
    

def searchAndReplace(filename, date):
    data = [line.rstrip() for line in open(filename, 'r')]
    cleandata = []
    for line in data:
        line = re.sub(r"(<type>)Original( Work</type>)", r"\1Literary\2", line)
        line = re.sub("(<type>)Primary(</type>)", r"\1Article\2", line)
        line = re.sub("(<record>)", r"\1\n<dateadd>" + date + r"</dateadd>", line)
        line = re.sub("(</idref>)", r"\1\n<reflink></reflink>", line)
        line = re.sub("(<liftjnl>.*</liftjnl>)\n(<interim>.*</interim>)", r"\2\n\1", line, re.M)
        cleandata.append(line)
    outf = open(filename, 'w')
    for line in cleandata:
        outf.write(line + "\n")
    outf.close()

def checkNumbers(filename):
    fields = '''dururl type texttype interim ftnum idref dateadd record'''.split()
    seen = defaultdict(int)
    data = open(filename, 'r')
    for line in data:
        for field in fields:
            if re.search(r'<' + field + r'>', line):
                seen[field] += 1
    data.close()
    for field in seen.keys():
        print field + ': ' + str(seen[field])


def do_it():
    pass

# #dtable = { 'sanitise': sanitise }
# dtable = {}
# for name in valid_subcommands:
#     dtable[name] = lambda args: eval(name + "()")
# #+ "(" + args + ")"


# #sanitise(sys.argv[2], sys.argv[3])
# #sanitise(args)

# #dtable[subcommand](args)

eval(subcommand + "(" + args + ")")
