#!/usr/local/bin/perl
# Emacs: Use -*- cperl -*- mode.

use 5.008;

use Getopt::Long;
use Pod::Usage;
use POSIX qw(strftime getcwd);

use warnings;
use strict;

# Global variables:
my ($recno, $ftnum_there, %tocrecords, $issn_missing, 
    $issue_missing, %missing, %all_types, %ignore_types, 
    $ignore_missing, $no_reviews_in_startend_check);
$recno=$ftnum_there=0;

USAGE: {
    my $command_line = join(' ', $0, @ARGV);

## Option flags:
    my $man = 0;
    my $help = 0;
    my $lit = 1;
    my $rev = 1;
    my $art =1;
    my $missing = 0; #Don't list missing ISSN/issue unless asked. 
    my $revse = 0; #Don't report false discrepancies for reviews with no <startend> field.

## Parse options and print usage if there is a syntax error,
## or if usage was explicitly requested.
    GetOptions('help|?' => \$help,
               'man' => \$man,
               'lit!' => \$lit,
               'rev!' => \$rev,
               'art!' => \$art,
               'missing!' => \$missing,
               'revse!' => \$revse) or pod2usage(2);
    pod2usage(1) if $help;
    pod2usage(-verbose => 2) if $man;
## If no arguments were given, then allow STDIN to be used only
## if it's not connected to a terminal (otherwise print usage)
    pod2usage("$0: No file given.\nTry\n    $0 -help\nfor options.")  if ((@ARGV == 0) && (-t STDIN));

print "Report from: $command_line\n";
print "Generated by ", getlogin, " on ", strftime("%x %X.\n",localtime);
print "Working directory: ", getcwd,  "\n";

if (-t STDOUT) {
    print "I'm going to write all over your terminal!\nType Ctrl-C to kill me.\n";
}


    $ignore_types{'Article'}=1 if !$art;
    $ignore_types{'Review'}=1 if !$rev;
    $ignore_types{'Literary Work'}=1 if !$lit;
    $ignore_missing=!$missing;
    $no_reviews_in_startend_check = !$revse;
}

#read an entire record as a multiline string
$/ = "</record>";

RECORD: while (<>) {
    next unless m'<record>';
    $recno++;
    # get fields from between tags
    my ($idref) = m'<idref>(.*?)</idref>'s;
    my $issue = "";
    if (/<volissue>/) {
    	($issue) = m'<volissue>(.*?)</volissue>';
    	$issue =~ s/<\/?[^>]+>//g;
    	print $issue;
    }
    else {
    	($issue) = m'<issue>(.*?)</issue>'s;
    }
    my ($issn) = m'<ISSN>(.*?)</ISSN>'s;

    warn "idref missing\n", next unless $idref;
    $issue = "Missing", ++$issue_missing unless defined $issue;
    $issn  = "Missing", ++$issn_missing unless defined $issn;

    # check for existence of <ftnum> field
    # (change .* to .+ to check it's non-empty)
    m'<ftnum>.*?</ftnum>'s or next;
    $ftnum_there++;

    my ($type) = m'<type>(.*?)</type>'s;
    $type ||= "Missing";
    $all_types{$type}++;

    next RECORD if $ignore_types{$type};

    if (m'<interim>(.*?)</interim>'s) {$type .= " (Interim=$1)";}

    # Use this as the hash key for each group
    my ($subheading) = "ISSN: " . $issn . ",\tissue: " . $issue . "\n";

    # This if block skips over records for which
    # the ISSN or issue are missing.
    # Comment out the or $issue eq "Missing"
    # to pretend "Missing" is a valid issue number.
    
    if ($issn eq "Missing"
    	or $issue eq "Missing"
    	)
    {
    	$subheading = "$issn/$issue: $type\n";
        push @{ $missing{$subheading} }, $idref unless $ignore_missing;
#        print STDERR "$issn/$issue: $type: $idref\n";
        next RECORD;
    }

#Match dispdate subfield of sortpub:
    my ($dispdate) = m'<sortpub>.*?<dispdate>(.*?)</dispdate>.*?</sortpub>'s;
#Match contents of startend tag
    my ($startend) = m'<startend>(.*?)</startend>'s;

    $dispdate ||= "Type: $type";
    $startend ||= "Type: $type";

# The next two lines were used for debugging purposes.
#    print $subheading, $idref, "\t$recno\n$startend\n$dispdate\n", ;
#    warn "record exists!\n" if ( exists $tocrecords{$subheading}{$idref} );

    # Store info into hash of groups
    $tocrecords{$subheading}{$idref} = {
        dispdate => $dispdate,
        startend => $startend,
#        type => $type,
    };
}

MUMBLE: {
printf("I found %d records, of which %d contain%s the <ftnum> field.\n",
       $recno, $ftnum_there, ($ftnum_there==1)?'s':'');
printf("%d record%s no ISSN\n",
       $issn_missing, ($issn_missing==1)?' has':'s have')
    if $issn_missing;
printf("%d record%s no 'issue'\n",
       $issue_missing, ($issue_missing==1)?' has':'s have')
    if $issue_missing;
print "The records were of these types:\n";
foreach my $type (keys %all_types) { 
    print qq("$type" : ), $all_types{$type}, "\n";
}
print "All records of types \"", join(qq(" "), keys %ignore_types), "\" were ignored\n" if %ignore_types;

}

GROUP: foreach my $subheading (sort keys %tocrecords) {
    my $group = $tocrecords{$subheading};
    my ($first, @rest) = values %$group;
    my $dispdate_mismatch = 0;
    my $startend_mismatch = 0;
    foreach my $second (@rest) {
        $dispdate_mismatch=1 if ($$first{dispdate} ne $$second{dispdate});
        $startend_mismatch=1 if ($$first{startend} ne $$second{startend});
    }
#    if ($dispdate_mismatch) {
#        print "\n", $subheading, "Dispdate discrepancy:\n";
#        foreach my $idref (sort keys %$group) {
#            my $record = $$group{$idref};
#            print $idref, "\t\t", $$record{dispdate}, "\n";
#        }
#    }
    if ($dispdate_mismatch) {
        my %dates;
        foreach my $idref (sort keys %$group) {
            my $record = $$group{$idref};
            push @{$dates{$$record{dispdate}}}, $idref;
        }
        print "\n", $subheading, "Dispdate discrepancy (", scalar(keys %dates), " sets):\n";
        foreach my $ddate (sort keys %dates) {
            my $idrefs=$dates{$ddate};
            print $$idrefs[0], "\t\t$ddate\n";
            print join("\t\t.\n", @$idrefs[1..$#$idrefs]), "\t\t$ddate\n" if (@$idrefs>1);
        }
    }
#    if ($startend_mismatch) {
#        print "\n", $subheading, "Startend discrepancy:\n";
#        foreach my $idref (sort keys %$group) {
#            my $record = $$group{$idref};
#            print $idref, "\t", $$record{startend}, "\n";
#
#        }
#    }
    if ($startend_mismatch) {{
        my %starts;
        foreach my $idref (sort keys %$group) {
            my $record = $$group{$idref};
            push @{$starts{$$record{startend}}}, $idref;
        }
        
        #Keep quiet if the mismatch was caused by Reviews
        last if ($no_reviews_in_startend_check and scalar(keys %starts) == 2 and exists $starts{"Type: Review"});
        
        print "\n", $subheading, "Startend discrepancy (", scalar(keys %starts), " sets):\n";
        foreach my $se (sort keys %starts) {
            my $idrefs=$starts{$se};
            print $$idrefs[0], "\t$se\n";
            print join("\t.\n", @$idrefs[1..$#$idrefs]), "\t$se\n" if (@$idrefs>1);
        
        }
    }}  #last jumps to here
}

print "\n\nThe following records have either ISSN or 'issue' missing:\n\n" if scalar %missing;

MISSING: foreach my $subheading (sort keys %missing) {
    my $idrefs=$missing{$subheading};
    next if (@$idrefs < 2);
    print "\n$subheading";
    foreach my $idref (@$idrefs) {
        print $idref, "\n";
    }
}

#End of program, documentation follows

__END__


=head1 NAME

toccheck.plx - Check ABELL file for inconsistent records

=head1 SYNOPSIS

toccheck.plx [options] [file]

=head1 OPTIONS

=over 8

=item B<-help>

Prints a brief help message and exits.

=item B<-man>

Prints a more-helpful help page and exits.

=item B<-noart>, B<-norev>, B<-nolit>

Ignore records of type "Article", "Review" and "Literary Work" respectively.

=item B<-revse>

Allow records of type "Review", but without <startend> or <interim> 
fields, to cause Startend discrepancies. Default is to ignore these.

=item B<-missing>

List records with missing ISSN or issue number.

=item file

The file(s) to read records from.

=back

Example:
    toccheck.plx abfile.txt >toccheck.log


=head1 DESCRIPTION

B<This program> will read the given input file, which should
contain ABELL records between <record>...</record> pairs.

The output is a list of discrepancies found in the file,
in the <dispdate> and <startend> fields.

Each record is scanned for the fields:

=over 4

=item <idref>

The unique record number, e.g. R01689958.

=item <ISSN>

The ISSN for a journal or book, e.g. 00030678.

=item <issue>

The issue number for a journal, e.g. (55:2).

=item <ftnum>

Er... We just ignore records without this one.

=item <startend>

A field which looks like
C<< <startend><start>20030601</start><end>20030630</end></startend> >>.

This is expected to be the same for each record with the same 
ISSN/Issue pair.

=item <dispdate>

Date of issue? Subfield of <sortpub>.
All records for the same ISSN/Issue pair should have
the same Dispdate, e.g. Aug 2003.

=item type

This field is expected to contain either "Article", 
"Review" or "Literary Work". Records of these
types can be ignored by giving the appropriate option.
The most useful is B<-norev> since the reviews tend not to
have <startend> fields.

=back

If the <startend> or <dispdate> fields are missing from
a record, the record's type will be stated instead.

In addition, if the B<-missing> option is given, records which
have no ISSN, or which have no issue number are listed at the 
end of the report.

The generated report is written to STDOUT. You probably want
to redirect this to a file by putting C<< >toccheck.log >>
on the end of the command. Running in the background is a
good idea too, as it took about 30 seconds last time I tried.

=head1 AUTHOR

Jason Holt, for ProQuest. (2004-10-25)

=head1 NOTES

The report as requested in "toccheck.doc" is produced by the command:

toccheck.plx /dc/elp/lionref/data/master/ab_ftjn.txt >toccheck.log


=cut
