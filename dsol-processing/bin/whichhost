#!/bin/bash
# -*- Mode: shell-script -*-

# Print the hostname of the server on which the specified
# file system lives, or connect to it over ssh(1) if the
# -s flag is given.

usage() {
    err "Usage: `basename $0` [-h|-s] /path"
}

err() {
    echo "${1}" >&2
}     

# Make sure the automounter has mounted the requested path.
# If not, sometimes we get bad results.
# This can be done in a subshell

prod_amd() {
    (cd "${1}")
}

# Test for option -s or -h

while getopts hs o
do
    case "${o}" in
    h) 
        usage
        exit 1
        ;;
    s)
        SSH=1
    esac
done
shift $((${OPTIND}-1))

if [ "X${1}" = "X" ]
then
    err "No path given"
    usage
    exit 1
elif [ -d "${1}" ]
then
    prod_amd "${1}"
elif [ -f "${1}" ]
then
    prod_amd `dirname "${1}"`
else
    err "Not a file or directory: ${1}"
    exit 1
fi

GDF=/opt/sfw/bin/gdf
# Because GNU tools are horrible and noisy, we need to suppress the
# useless header line. Why they can't put in a -s option to generate
# script-friendly output is beyond me...
FS=$(${GDF} ${1} | awk '!/Filesystem/ {print $1}')

case ${FS} in
*:*)
    # Anything up to the ':' is the hostname. Grab it
    # and either connect over ssh(1), or echo to the terminal.
    HOST=$(echo ${FS} | cut -d : -f 1)
    if [ "X${SSH}" = "X1" ]
    then
        echo "Connecting to ${HOST}..."
        ssh ${HOST}
    else
        echo ${HOST}
    fi
    ;;
auto_*)
    # one of the automounter listen points
    err "Not a mountable file system"
    exit 3
    ;;
*/*)
    # If there's no ':' in the path spec, and the path spec doesn't 
    # begin with 'auto_', and we see a / character, filesystem is local
    # to the current host.
    err "File system is on this host (`hostname | cut -d '.' -f 1`)" 
    exit 3
    ;;
*)
    err "Something odd has happened. Try not to panic..."
    exit 42
    ;;
esac



